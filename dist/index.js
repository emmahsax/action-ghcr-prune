(()=>{var __webpack_modules__={799:(e,t,n)=>{const a=n(486);const{Buffer:r}=n(300);const createDockerAPIClient=()=>{const e=new a.HttpClient("github-action");return e};const dockerAPIGet=async(e,t,n,a,r)=>{let s=await e.get(`https://ghcr.io/v2/${n}/${a}/${r}`);const o=s.headers["www-authenticate"];const i=/Bearer realm="(.*?)",service="(.*?)",scope="(.*?)"/.exec(o);const[,c,u,g]=i;s=await e.get(`${c}?service=${u}&scope=${g}`,{headers:{Authorization:`Bearer ${t}`}});const{token:p}=await s.json();s=await e.get(`https://ghcr.io/v2/${n}/${a}/${r}`,{headers:{Authorization:`Bearer ${p}`}});if(s.message.statusCode!=200){throw new Error(`Docker API request at ${url} was not successful. Status code: ${s.message.statusCode}, Status message: ${s.message.statusMessage}`)}return s};const getManifest=e=>async t=>{const n=await e(`manifests/${t}`);const a=await n.readBody();const r=JSON.parse(a);return r};e.exports={getManifest:getManifest,createDockerAPIClient:createDockerAPIClient,dockerAPIGet:dockerAPIGet}},354:e=>{const deleteAuthenticatedUserContainerVersion=e=>t=>n=>e.rest.packages.deletePackageVersionForAuthenticatedUser({package_type:"container",package_name:t,package_version_id:n.id});const deleteOrgContainerVersion=e=>(t,n)=>a=>e.rest.packages.deletePackageVersionForOrg({package_type:"container",org:t,package_name:n,package_version_id:a.id});const deleteUserContainerVersion=e=>(t,n)=>a=>e.rest.packages.deletePackageVersionForUser({package_type:"container",username:t,package_name:n,package_version_id:a.id});const listAuthenticatedUserContainerVersions=e=>t=>(n,a=1)=>e.rest.packages.getAllPackageVersionsForPackageOwnedByAuthenticatedUser({package_type:"container",package_name:t,page:a,per_page:n,state:"active"});const listOrgContainerVersions=e=>(t,n)=>(a,r=1)=>e.rest.packages.getAllPackageVersionsForPackageOwnedByOrg({package_type:"container",org:t,package_name:n,page:r,per_page:a,state:"active"});const listUserContainerVersions=e=>(t,n)=>(a,r=1)=>e.rest.packages.getAllPackageVersionsForPackageOwnedByUser({package_type:"container",username:t,package_name:n,page:r,per_page:a,state:"active"});e.exports={deleteAuthenticatedUserContainerVersion:deleteAuthenticatedUserContainerVersion,deleteOrgContainerVersion:deleteOrgContainerVersion,deleteUserContainerVersion:deleteUserContainerVersion,listAuthenticatedUserContainerVersions:listAuthenticatedUserContainerVersions,listOrgContainerVersions:listOrgContainerVersions,listUserContainerVersions:listUserContainerVersions}},154:(e,t,n)=>{const a=n(942);const{digestFilter:r}=n(426);const s=100;const sortByVersionCreationDesc=(e,t)=>-e.created_at.localeCompare(t.created_at);const getMultiPlatPruningList=(e,t)=>async n=>{a.info("Crawling through pruning list for multi-platform images...");const s=[];for(const e of n){const n=await t(e.metadata.container.tags[0]);if(n.mediaType!="application/vnd.docker.distribution.manifest.list.v2+json"){continue}for(const e of n.manifests){a.info(`Found subimage: ${e.digest}`);s.push(e.digest)}}if(s.length){const t=r(s);const n=getPruningList(e,t)(0);return n}else{return undefined}};const getPruningList=(e,t)=>async(n=0)=>{let r=[];let o=1;let i=0;a.info("Crawling through all versions to build pruning list...");do{const{data:n}=await e(s,o);i=n.length;const c=n.filter(t);r=[...r,...c];a.info(`Found ${c.length} versions to prune out of ${i} on page ${o}`);o++}while(i>=s);if(n>0){a.info(`Keeping the last ${n} versions, sorted by creation date`);return r.sort(sortByVersionCreationDesc).slice(n)}return r};const prune=e=>async t=>{const n=[];try{a.startGroup(`Pruning ${t.length} versions...`);for(const r of t){a.info(`Pruning version #${r.id} named '${r.name}'...`);await e(r);n.push(r)}a.endGroup()}catch(e){a.endGroup();a.error(`Failed to prune because of: ${e}`)}a.notice(`Pruned ${n.length} versions`);return n};e.exports={getPruningList:getPruningList,prune:prune,getMultiPlatPruningList:getMultiPlatPruningList}},426:e=>{const t=1e3*60*60*24;const daysBetween=(e,n=new Date)=>Math.floor((n.getTime()-e.getTime())/t);const anyRegexMatch=e=>t=>e.some((e=>t.some((t=>t.match(e)))));const versionFilter=e=>t=>{const{keepTags:n,keepTagsRegexes:a,keepYoungerThan:r,pruneTagsRegexes:s,pruneUntagged:o}=e;const i=new Date(t.created_at);const c=daysBetween(i);if(r>c){return false}const u=t.metadata.container.tags;if(o&&(!u||!u.length)){return true}if(n&&u&&n.some((e=>u.includes(e)))){return false}if(a&&u&&anyRegexMatch(a)(u)){return false}if(s&&u&&anyRegexMatch(s)(u)){return true}return false};const digestFilter=e=>t=>{const n=e.find((e=>t.name==e));if(n){return true}else{return false}};e.exports={versionFilter:versionFilter,digestFilter:digestFilter}},942:module=>{module.exports=eval("require")("@actions/core")},234:module=>{module.exports=eval("require")("@actions/github")},486:module=>{module.exports=eval("require")("@actions/http-client")},300:e=>{"use strict";e.exports=require("buffer")}};var __webpack_module_cache__={};function __nccwpck_require__(e){var t=__webpack_module_cache__[e];if(t!==undefined){return t.exports}var n=__webpack_module_cache__[e]={exports:{}};var a=true;try{__webpack_modules__[e](n,n.exports,__nccwpck_require__);a=false}finally{if(a)delete __webpack_module_cache__[e]}return n.exports}if(typeof __nccwpck_require__!=="undefined")__nccwpck_require__.ab=__dirname+"/";var __webpack_exports__={};(()=>{const e=__nccwpck_require__(942);const t=__nccwpck_require__(234);const{deleteAuthenticatedUserContainerVersion:n,deleteOrgContainerVersion:a,deleteUserContainerVersion:r,listAuthenticatedUserContainerVersions:s,listOrgContainerVersions:o,listUserContainerVersions:i}=__nccwpck_require__(354);const{getMultiPlatPruningList:c,getPruningList:u,prune:g}=__nccwpck_require__(154);const{versionFilter:p}=__nccwpck_require__(426);const{getManifest:d,createDockerAPIClient:l,dockerAPIGet:_}=__nccwpck_require__(799);const asBoolean=e=>"true"==String(e);const versionSummary=e=>JSON.stringify({id:e.id,name:e.name,created_at:e.created_at,tags:e.metadata.container.tags});const dryRunDelete=t=>new Promise((n=>{e.info(`Dry-run pruning of: ${versionSummary(t)}`);n()}));const writeSummary=async(t,n,a,r)=>{const s=a.length===r.length;let o=e.summary.addHeading(`Pruning versions for container: ${t}`,2);if(n){o=o.addRaw(":warning: This is a dry run, no container versions were actually deleted.")}else{o=o.addRaw(`${s?":white_check_mark:":":x:"} ${r.length} out of ${a.length} identified versions were pruned successfully.`)}await o.addHeading("Pruned versions",3).addRaw(`The following ${r.length} versions were successfully pruned:`).addTable([[{data:"ID",header:true},{data:"Name",header:true},{data:"Created at",header:true},{data:"Tags",header:true}],...r.map((e=>[String(e.id),e.name,e.created_at.replace("T"," "),e.metadata.container.tags.join(", ")]))]).write()};const run=async()=>{try{const f=e.getInput("token");const m=e.getInput("organization");const h=e.getInput("user");if(m&&h){e.setFailed("Inputs `organization` and `user` are mutually exclusive and must not both be provided in the same run.");return}const k=e.getInput("container");const w=asBoolean(e.getInput("prune-multi-platform"));const v=asBoolean(e.getInput("dry-run"));const y=Number(e.getInput("keep-last"));const b=e.getInput("tag-regex")?[e.getInput("tag-regex")]:null;const $=asBoolean(e.getInput("prune-untagged"))||asBoolean(e.getInput("untagged"));if(w&&$){e.setFailed("Inputs `prune-multi-platform` and `prune-untagged` are mutually exclusive and must not both be provided in the same run.");return}if(w&&!(m||h)){e.setFailed("Inputs `prune-multi-platform` requires either `organization` or `user` to defined");return}const x={keepTags:e.getMultilineInput("keep-tags"),keepTagsRegexes:e.getMultilineInput("keep-tags-regexes"),keepYoungerThan:Number(e.getInput("keep-younger-than"))||Number(e.getInput("older-than")),pruneTagsRegexes:e.getInput("prune-tags-regexes")?e.getMultilineInput("prune-tags-regexes"):b,pruneUntagged:$};const I=t.getOctokit(f);let P;let C;let F;if(h){P=i(I)(h,k);C=v?dryRunDelete:r(I)(h,k);F=h}else if(m){P=o(I)(m,k);C=v?dryRunDelete:a(I)(m,k);F=m}else{P=s(I)(k);C=v?dryRunDelete:n(I)(k)}const V=p(x);const q=await u(P,V)(y);if(w){const e=l();const t=_(e,f,F,k);const n=d(t);const a=await c(P,n)(q);if(a){q.push(...a)}}e.info(`Found a total of ${q.length} versions to prune`);const A=await g(C)(q);await writeSummary(k,v,q,A);if(A.length!==q.length){e.setFailed(`Failed to prune some versions: ${A.length} out of ${q.length} versions were pruned`)}e.setOutput("count",A.length);e.setOutput("prunedVersionIds",A.map((e=>e.id)));e.setOutput("dryRun",v)}catch(t){e.setFailed(t.message)}};run()})();module.exports=__webpack_exports__})();